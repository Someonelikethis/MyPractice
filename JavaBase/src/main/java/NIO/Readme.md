#### Java传统IO与NIO

| 传统的IO            | NIO             |
| ------------------- | --------------- |
| 阻塞(BIO)           | 支持非阻塞      |
| 面向流的I/O，速度慢 | 面向缓冲区的I/O |
| Stream是单向的      | Channel是双向的 |

#### NIO三大核心部分——Channel(通道)、Buffer(缓冲区)、Selector(选择器)

通道是数据的载体，是数据的传输通道，而缓冲区是存储数据的地方

##### Buffer
    缓冲区实际上是一个容器对象，即数组
    NIO中所有的数据都用缓冲区处理
    常用方法：
    flip(): 写模式转换成读模式
    rewind()：将 position 重置为 0 ，一般用于重复读。
    compact(): 将未读取的数据拷贝到 buffer 的头部位。

| 参数     | 说明                                            |
| -------- | ----------------------------------------------- |
| capacity | 缓冲数组的总长度                                |
| limit    | 第一个不应该被读写的元素的位置                  |
| position | 读写的下一个元素的位置                          |
| mark     | 标记位置，通过reset方法可以回到这个位置继续读写 |

```
mark <= position <= limit <= capacity
```

##### Channel

    Channel用做从Buffer中读写数据，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。

##### Selector
    Selector是SelectableChannel对象的多路复用器，所有希望采用非阻塞方式进行通信的Channel都应该注册到Selector对象
    
    Selector用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个Channel，从而实现非阻塞

#### I/O模型

##### 阻塞与非阻塞

    阻塞I/O是最常用的IO模型
    阻塞：数据没有准备好时，线程会阻塞。  缺省模式
    非阻塞：数据没有准备好时，线程不会阻塞，通常会采用轮询的方式去检查数据是否准备好

##### 同步与异步

    同步和异步都是基于应用程序和操作系统处理IO事件所采用的方式
    同步：应用程序直接参与IO读写的操作。
    异步：所有的IO读写交给搡作系统去处理，应用程序只需要等待通知。

##### I/O复用模型

    一个线程(Selector)掌握IO资源， 多个Channel注册到一个Selector上(所有IO操作阻塞在Selector上，由Selector去分配IO资源)，由Selector去检测Channel状态，从而分配IO资源，实现IO复用。
    epoll使用基于事件驱动的方式代替顺序扫描

##### 信号驱动I/O模型

    当Channel就绪时(数据准备好时)发出信号，通知此时可以进行IO操作。
    信号驱动是通知何时可以进行IO操作，异步IO是通知何时操作已完成

#### I/O多路复用技术

    把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求

#### 主要类

​    缓冲区 ByteBuffer
​    管道   Pipe
​    通道   Channel
​    文件通道  FileChannel
​    多路复用器 Selector

    所有的Channel默认都是阻塞模式

#### 网络编程

网络编程的基本模型是C/S模型，也就是进程间通信

##### BIO(同步阻塞IO——传统IO)

一请求一应答通信

并发量和线程数1：1

##### NIO(同步非阻塞)



##### AIO(异步非阻塞   NIO2.0)



​	

